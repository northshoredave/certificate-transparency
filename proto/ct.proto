syntax = "proto2";

package ct;
option java_package = "org.certificatetransparency.ctlog.proto";


////////////////////////////////////////////////////////////////////////////////
// These protocol buffers should be kept aligned with the I-D.                //
////////////////////////////////////////////////////////////////////////////////

// RFC 5246
message DigitallySigned {
  enum HashAlgorithm {
    NONE = 0;
    MD5 = 1;
    SHA1 = 2;
    SHA224 = 3;
    SHA256 = 4;
    SHA384 = 5;
    SHA512 = 6;
  }

  enum SignatureAlgorithm {
    ANONYMOUS = 0;
    RSA = 1;
    DSA = 2;
    ECDSA = 3;
  }

  // 1 byte
  optional HashAlgorithm hash_algorithm = 1 [ default = NONE ];
  // 1 byte
  optional SignatureAlgorithm sig_algorithm = 2 [ default = ANONYMOUS ];
  // 0..2^16-1 bytes
  optional bytes signature = 3;
}

enum LogEntryType {
  X509_ENTRY = 0;
  PRECERT_ENTRY = 1;
  // Not part of the I-D, and outside the valid range.
  UNKNOWN_ENTRY_TYPE = 65536;
}

message X509ChainEntry {
  // <1..2^24-1>
  optional bytes leaf_certificate = 1;
  // <0..2^24-1>
  // A chain from the leaf to a trusted root
  // (excluding leaf and possibly root).
  repeated bytes certificate_chain = 2;
}

// opaque TBSCertificate<1..2^16-1>;
// struct {
//   opaque issuer_key_hash[32];
//   TBSCertificate tbs_certificate;
// } PreCert;
// TODO(benl, ekasper): call this something more original in the I-D.
message PreCert {
  optional bytes issuer_key_hash = 1;
  optional bytes tbs_certificate = 2;
}

message PrecertChainEntry {
  // <1..2^24-1>
  optional bytes pre_certificate = 1;
  // <0..2^24-1>
  // The chain certifying the precertificate, as submitted by the CA.
  repeated bytes precertificate_chain = 2;

  // PreCert input to the SCT. Can be computed from the above.
  // Store it alongside the entry data so that the signers don't have to
  // parse certificates to recompute it.
  optional PreCert pre_cert = 3;
}

message LogEntry {
  optional LogEntryType type = 1 [ default = UNKNOWN_ENTRY_TYPE ];

  optional X509ChainEntry x509_entry = 2;

  optional PrecertChainEntry precert_entry = 3;
}

enum SignatureType {
  CERTIFICATE_TIMESTAMP = 0;
  // TODO(ekasper): called tree_hash in I-D.
  TREE_HEAD = 1;
}

enum Version {
  V1 = 0;
  // Not part of the I-D, and outside the valid range.
  UNKNOWN_VERSION = 256;
}

message LogID {
  // 32 bytes
  optional bytes key_id = 1;
}

// TODO(ekasper): implement support for id.
message SignedCertificateTimestamp {
  optional Version version = 1 [ default = UNKNOWN_VERSION ];
  optional LogID id = 2;
  // UTC time in milliseconds, since January 1, 1970, 00:00.
  optional uint64 timestamp = 3;
  optional DigitallySigned signature = 4;
  optional bytes extensions = 5;
}

message SignedCertificateTimestampList {
  // One or more SCTs, <1..2^16-1> bytes each
  repeated bytes sct_list = 1;
}

enum MerkleLeafType {
  TIMESTAMPED_ENTRY = 0;
  UNKNOWN_LEAF_TYPE = 256;
}

message SignedEntry {
  optional bytes x509 = 1;
  optional PreCert precert = 2;
}

message TimestampedEntry {
  optional uint64 timestamp = 1;
  optional LogEntryType entry_type = 2;
  optional SignedEntry signed_entry = 3;
  optional bytes extensions = 4;
}

// Stuff that's hashed into a Merkle leaf.
message MerkleTreeLeaf {
  // The version of the corresponding SCT.
  optional Version version = 1 [ default = UNKNOWN_VERSION ];
  optional MerkleLeafType type = 2 [ default = UNKNOWN_LEAF_TYPE ];
  optional TimestampedEntry timestamped_entry = 3;
}

// TODO(benl): No longer needed?
//
// Used by cpp/client/ct: it assembles the one from the I-D JSON
// protocol.
//
// Used by cpp/server/blob-server: it uses one to call a variant of
// LogLookup::AuditProof.
message MerkleAuditProof {
  optional Version version = 1 [ default = UNKNOWN_VERSION ];
  optional LogID id = 2;
  optional uint64 tree_size = 3;
  optional uint64 timestamp = 4;
  optional uint64 leaf_index = 5;
  repeated bytes path_node = 6;
  optional DigitallySigned tree_head_signature = 7;
}

message ShortMerkleAuditProof {
  required uint64 leaf_index = 1;
  repeated bytes path_node = 2;
}

////////////////////////////////////////////////////////////////////////////////
// Finally, stuff that's not in the I-D but that we use internally            //
// for logging entries and tree head state.                                   //
////////////////////////////////////////////////////////////////////////////////

message LoggedCertificatePB {
  optional uint64 sequence_number = 1;
  optional bytes merkle_leaf_hash = 2;
  message Contents {
    optional SignedCertificateTimestamp sct = 1;
    optional LogEntry entry = 2;
  }
  required Contents contents = 3;
}

message SignedTreeHead {
  // The version of the tree head signature.
  // (Note that each leaf has its own version, so a V2 tree
  // can contain V1 leaves, too.
  optional Version version = 1 [ default = UNKNOWN_VERSION ];
  optional LogID id = 2;
  optional uint64 timestamp = 3;
  optional uint64 tree_size = 4;
  optional bytes sha256_root_hash = 5;
  optional DigitallySigned signature = 6;
}

// Stuff the SSL client spits out from a connection.
message SSLClientCTData {
  optional LogEntry reconstructed_entry = 1;
  optional bytes certificate_sha256_hash = 2;

  message SCTInfo {
    // There is an entry + sct -> leaf hash mapping.
    optional SignedCertificateTimestamp sct = 1;
    optional bytes merkle_leaf_hash = 2;
  }
  repeated SCTInfo attached_sct_info = 3;
}

///////////////////////////////////////////////////////////
//AKAMAI
// Added to accomplish Akamai specific goals.  
//   1) Talking to DB
//   2) Secondary indexing in DB
//
///////////////////////////////////////////////////////////

message X509Root {
  // <0..2^24-1>
  // A set of x509Roots
  // (excluding leaf and possibly root).
  repeated bytes roots = 2;
}

message LoggedCertificatePBList {
  repeated LoggedCertificatePB logged_certificate_pbs = 1;
}

//Data battery doesn't currently support secondary indexing
//  Memory used by the index should be inconsequential so using uint64 instead of uint32 seems ok
message DataBatteryIndex {
  optional uint64 first_key = 1; //First key in the table. 
  optional uint64 last_key = 2; //Last key in the table.  If none defined we have no rows yet
  optional uint64 last_update = 3; //Last time table was updated
}

message DataBatteryPeers {
  message peer {
    optional string id = 1;
    optional uint64 timestamp = 2;
  }
  //Actual in use peers
  repeated peer peers = 1;
  //Any peer that has been removed.  This allows us to create a tool to clean up the pending table
  //  should we ever need to.  Remember each time a CT instance starts it creates another unique peer
  //  entry that is never cleaned up
  repeated peer removed_peers = 2;
}

message AkamaiConfig {
  //Name of DataBattery leaves table
  optional string db_leaves = 1 [ default = "leaves" ];
  //Name of DataBattery pending table
  optional string db_pending = 2 [ default = "pending" ];
  /* Max value size for a given key in DataBattery.  If 0, then use
   * the value retrieved by doing a limits lookup on table in DB.  If not, then use min of this
   * entry and value retrieved from DB
   */
  optional uint64 db_max_entry_size = 3 [ default = 0 ];
  //Fixed wait time in seconds added to random time to verify that peer update was successfull
  optional uint64 fixed_peer_delay = 4 [ default = 43200 ];
  //Random wait time in seconds added to fixed time to verify that peer update was successfull
  optional uint64 random_peer_delay = 5 [ default = 60 ];
  //Maximum age in seconds of peers last update before it is removed
  optional uint64 max_peer_age_removal = 6 [ default = 86400 ];
  //Max age in seconds of last peer update before you should stop answering queries
  optional uint64 max_peer_age_suspension = 7 [ default = 900 ];
  //How often to beat.  I.e. how often to update your peer timestamp
  optional uint64 heartbeat_freq = 8 [ default = 300 ];
  //How often to update the leaves from DataBattery
  optional uint64 leaves_update_freq = 9 [ default = 3600 ];
  //Minimum age of pending cert in seconds before it can be committed to the leaves table
  optional uint64 cert_min_age = 10 [ default = 43200 ];
  //How often to try and commit pending certs (in seconds).  Added to the peer delay.
  optional uint64 commit_delay = 11 [ default = 21600 ];
  //Delay added to commit delay (in seconds).  Determines how long to wait between committing pending certs
  optional uint64 commit_peer_delay = 12 [default = 60 ];
  //How often to check for new config
  optional uint64 config_delay = 13 [ default = 300 ];
  //How long to sleep in threads when some error occurs before trying again
  optional uint64 short_sleep = 14 [ default = 5 ];
  //How often to update query tables
  optional uint32 query_freq = 15 [ default = 180 ];
  //How much time a bucket spans for req_counts in seconds
  optional uint32 bucket_time = 16 [ default = 300 ];
  //What the bucket sizes to report. 
  repeated uint32 bucket_sets = 17;
  //Whether to publish cert_info query table
  optional bool publish_cert_info = 18;
  //What table to get root certs from and the key
  optional string db_root_table = 19 [ default = "leaves" ];
  optional string db_root_key = 20 [ default = "roots" ];
  //How much to add to the serialized size of a lcpb when add to a lcpbl (there is bit of array overhead when 
  //  it gets inserted into the list
  optional uint32 buffer_safety = 21 [ default = 100 ];
  //How often to check health in main thread
  optional uint32 health_check_freq = 22 [ default = 15 ];
  //How often to sign tree
  optional uint32 tree_sign_freq = 23 [ default = 15 ];
  //App name used by databattery for CT
  optional string db_app = 24 [ default = "ct" ];
  //Hostname for DataBattery
  optional string db_hostname = 25;
  //Port or service for DataBattery
  optional string db_serv = 26 [ default = "443" ];
  //Preface when GET, PUT access DB
  optional string db_preface = 27;
  //Cert to use when accessing DataBattery, filename only
  optional string db_cert = 28 [ default = "ssl_cert\\.([0-9]+)\\.certificate" ];
  //Key to use when accessing DataBattery, filename only
  optional string db_key = 29 [ default = "ssl_cert\\.([0-9]+)\\.private_key" ];
  //What directory to look in for DataBattery cert/key
  optional string db_cert_dir = 30 [ default = "/a/secrets/app/ssl_cert/" ];
  //What directory to write query tables in to get picked up by tabelprov
  optional string tableprov_dir = 31 [ default = "/a/provide_to_query" ];
  //name of limit to get max entry value size
  optional string db_request_bytes = 32 [ default = "request_bytes" ];
  //How long in seconds to delay between checking if db access cert has changed
  optional uint32 cert_check_delay = 33 [ default = 600 ]; 
  //Whether we should attempt to get ca roots from DB
  optional bool get_roots_from_db = 34 [ default = false ]; 
  //What the log cert name is, should be stored in the same directory as db_cert_dir
  optional string log_cert = 35 [ default = "ct_signer\\.([0-9]+)\\.certificate" ];
  //What key to store the log_cert to in the pending table
  optional string log_cert_db_key = 36 [ default = "log_cert" ];
  //Where to find the log_cert
  optional string log_cert_dir = 37 [ default = "/a/secrets/app/ct_signer/" ];
  //What is the name of the private log key
  optional string log_key = 38 [ default = "ct_signer\\.([0-9]+)\\.private_key" ];
  //What is the max_time_skew between peer time stamps to allow for quorum in ms
  optional uint64 max_time_skew = 39 [ default = 3600000 ];
  //What is the min number of peers that must agree on time for quorum
  optional uint32 quorum = 40 [ default = 2 ];
  //What entry to get the full root set from DB
  optional string db_all_root_key = 41 [ default = "all_roots" ];
}
