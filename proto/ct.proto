syntax = "proto2";

package ct;
option java_package = "org.certificatetransparency.ctlog.proto";


////////////////////////////////////////////////////////////////////////////////
// These protocol buffers should be kept aligned with the I-D.                //
////////////////////////////////////////////////////////////////////////////////

// RFC 5246
message DigitallySigned {
  enum HashAlgorithm {
    NONE = 0;
    MD5 = 1;
    SHA1 = 2;
    SHA224 = 3;
    SHA256 = 4;
    SHA384 = 5;
    SHA512 = 6;
  }

  enum SignatureAlgorithm {
    ANONYMOUS = 0;
    RSA = 1;
    DSA = 2;
    ECDSA = 3;
  }

  // 1 byte
  optional HashAlgorithm hash_algorithm = 1 [ default = NONE ];
  // 1 byte
  optional SignatureAlgorithm sig_algorithm = 2 [ default = ANONYMOUS ];
  // 0..2^16-1 bytes
  optional bytes signature = 3;
}

enum LogEntryType {
  X509_ENTRY = 0;
  PRECERT_ENTRY = 1;
  // Not part of the I-D, and outside the valid range.
  UNKNOWN_ENTRY_TYPE = 65536;
}

message X509ChainEntry {
  // <1..2^24-1>
  optional bytes leaf_certificate = 1;
  // <0..2^24-1>
  // A chain from the leaf to a trusted root
  // (excluding leaf and possibly root).
  repeated bytes certificate_chain = 2;
}

// opaque TBSCertificate<1..2^16-1>;
// struct {
//   opaque issuer_key_hash[32];
//   TBSCertificate tbs_certificate;
// } PreCert;
// TODO(benl, ekasper): call this something more original in the I-D.
message PreCert {
  optional bytes issuer_key_hash = 1;
  optional bytes tbs_certificate = 2;
}

message PrecertChainEntry {
  // <1..2^24-1>
  optional bytes pre_certificate = 1;
  // <0..2^24-1>
  // The chain certifying the precertificate, as submitted by the CA.
  repeated bytes precertificate_chain = 2;

  // PreCert input to the SCT. Can be computed from the above.
  // Store it alongside the entry data so that the signers don't have to
  // parse certificates to recompute it.
  optional PreCert pre_cert = 3;
}

message LogEntry {
  optional LogEntryType type = 1 [ default = UNKNOWN_ENTRY_TYPE ];

  optional X509ChainEntry x509_entry = 2;

  optional PrecertChainEntry precert_entry = 3;
}

enum SignatureType {
  CERTIFICATE_TIMESTAMP = 0;
  // TODO(ekasper): called tree_hash in I-D.
  TREE_HEAD = 1;
}

enum Version {
  V1 = 0;
  // Not part of the I-D, and outside the valid range.
  UNKNOWN_VERSION = 256;
}

message LogID {
  // 32 bytes
  optional bytes key_id = 1;
}

// TODO(ekasper): implement support for id.
message SignedCertificateTimestamp {
  optional Version version = 1 [ default = UNKNOWN_VERSION ];
  optional LogID id = 2;
  // UTC time in milliseconds, since January 1, 1970, 00:00.
  optional uint64 timestamp = 3;
  optional DigitallySigned signature = 4;
  optional bytes extensions = 5;
}

message SignedCertificateTimestampList {
  // One or more SCTs, <1..2^16-1> bytes each
  repeated bytes sct_list = 1;
}

enum MerkleLeafType {
  TIMESTAMPED_ENTRY = 0;
  UNKNOWN_LEAF_TYPE = 256;
}

message SignedEntry {
  optional bytes x509 = 1;
  optional PreCert precert = 2;
}

message TimestampedEntry {
  optional uint64 timestamp = 1;
  optional LogEntryType entry_type = 2;
  optional SignedEntry signed_entry = 3;
  optional bytes extensions = 4;
}

// Stuff that's hashed into a Merkle leaf.
message MerkleTreeLeaf {
  // The version of the corresponding SCT.
  optional Version version = 1 [ default = UNKNOWN_VERSION ];
  optional MerkleLeafType type = 2 [ default = UNKNOWN_LEAF_TYPE ];
  optional TimestampedEntry timestamped_entry = 3;
}

// TODO(benl): No longer needed?
//
// Used by cpp/client/ct: it assembles the one from the I-D JSON
// protocol.
//
// Used by cpp/server/blob-server: it uses one to call a variant of
// LogLookup::AuditProof.
message MerkleAuditProof {
  optional Version version = 1 [ default = UNKNOWN_VERSION ];
  optional LogID id = 2;
  optional uint64 tree_size = 3;
  optional uint64 timestamp = 4;
  optional uint64 leaf_index = 5;
  repeated bytes path_node = 6;
  optional DigitallySigned tree_head_signature = 7;
}

message ShortMerkleAuditProof {
  required uint64 leaf_index = 1;
  repeated bytes path_node = 2;
}

////////////////////////////////////////////////////////////////////////////////
// Finally, stuff that's not in the I-D but that we use internally            //
// for logging entries and tree head state.                                   //
////////////////////////////////////////////////////////////////////////////////

message LoggedCertificatePB {
  optional uint64 sequence_number = 1;
  optional bytes merkle_leaf_hash = 2;
  message Contents {
    optional SignedCertificateTimestamp sct = 1;
    optional LogEntry entry = 2;
  }
  required Contents contents = 3;
}

message SignedTreeHead {
  // The version of the tree head signature.
  // (Note that each leaf has its own version, so a V2 tree
  // can contain V1 leaves, too.
  optional Version version = 1 [ default = UNKNOWN_VERSION ];
  optional LogID id = 2;
  optional uint64 timestamp = 3;
  optional uint64 tree_size = 4;
  optional bytes sha256_root_hash = 5;
  optional DigitallySigned signature = 6;
}

// Stuff the SSL client spits out from a connection.
message SSLClientCTData {
  optional LogEntry reconstructed_entry = 1;
  optional bytes certificate_sha256_hash = 2;

  message SCTInfo {
    // There is an entry + sct -> leaf hash mapping.
    optional SignedCertificateTimestamp sct = 1;
    optional bytes merkle_leaf_hash = 2;
  }
  repeated SCTInfo attached_sct_info = 3;
}

///////////////////////////////////////////////////////////
//AKAMAI
// Added to accomplish Akamai specific goals.  
//   1) Talking to DB
//   2) Secondary indexing in DB
//
///////////////////////////////////////////////////////////

message X509Root {
  // <0..2^24-1>
  // A set of x509Roots
  // (excluding leaf and possibly root).
  repeated bytes roots = 2;
}

message LoggedCertificatePBList {
  repeated LoggedCertificatePB logged_certificate_pbs = 1;
}

//Data battery doesn't currently support secondary indexing
//  Memory used by the index should be inconsequential so using uint64 instead of uint32 seems ok
message DataBatteryIndex {
  optional uint64 first_key = 1; //First key in the table. 
  optional uint64 last_key = 2; //Last key in the table.  If none defined we have no rows yet
  optional uint64 last_update = 3; //Last time table was updated
}

message DataBatteryPeers {
  message peer {
    optional string id = 1;
    optional uint64 timestamp = 2;
  }
  //Actual in use peers
  repeated peer peers = 1;
  //Any peer that has been removed.  This allows us to create a tool to clean up the pending table
  //  should we ever need to.  Remember each time a CT instance starts it creates another unique peer
  //  entry that is never cleaned up
  repeated peer removed_peers = 2;
}

message AkamaiConfig {
  //Name of DataBattery leaves table
  optional string db_leaves = 1 [ default = "leaves" ];
  //Name of DataBattery pending table
  optional string db_pending = 2 [ default = "pending" ];
  /* Max value size for a given key in DataBattery.  If 0, then use
   * the value retrieved by doing a limits lookup on table in DB.  If not, then use min of this
   * entry and value retrieved from DB
   */
  optional uint64 db_max_entry_size = 3 [ default = 0 ];
  //Fixed wait time in seconds added to random time to verify that peer update was successfull
  optional uint64 fixed_peer_delay = 4 [ default = 3 ];
  //Random wait time in seconds added to fixed time to verify that peer update was successfull
  optional uint64 random_peer_delay = 5 [ default = 3 ];
  //Maximum age in seconds of peers last update before it is removed
  optional uint64 max_peer_age = 6 [ default = 20 ];
  //How often to beat.  I.e. how often to update your peer timestamp
  optional uint64 heartbeat_freq = 7 [ default = 10 ];
  //How often to update the leaves from DataBattery
  optional uint64 leaves_update_freq = 8 [ default = 20 ];
  //Minimum age of pending cert in seconds before it can be committed to the leaves table
  optional uint64 cert_min_age = 9 [ default = 10 ];
  //How often to try and commit pending certs (in seconds).  Added to the peer delay.
  optional uint64 commit_delay = 10 [ default = 10 ];
  //Delay added to commit delay (in seconds).  Determines how long to wait between committing pending certs
  optional uint64 commit_peer_delay = 11 [default = 10 ];
  //How often to check for new config
  optional uint64 config_delay = 12 [ default = 30 ];
  //How long to sleep in threads when some error occurs before trying again
  optional uint64 short_sleep = 13 [ default = 5 ];
  //How often to update query tables
  optional uint32 query_freq = 14 [ default = 180 ];
  //How much time a bucket spans for req_counts in seconds
  optional uint32 bucket_time = 15 [ default = 300 ];
  //What the bucket sizes to report. 
  repeated uint32 bucket_sets = 16;
  //Whether to publish cert_info query table
  optional bool publish_cert_info = 17;
  //What table to get root certs from and the key
  optional string db_root_table = 18 [ default = "leaves" ];
  optional string db_root_key = 19 [ default = "roots" ];
  //How much to add to the serialized size of a lcpb when add to a lcpbl (there is bit of array overhead when 
  //  it gets inserted into the list
  optional uint32 buffer_safety = 20 [ default = 100 ];
}
